# Task 1.7: Configure Route 53 DNS Records

**Objective**: Create DNS records in AWS Route 53 for internal hosts using Middle Earth themed names.

**Steps**:
1. Access AWS Console: https://console.aws.amazon.com/route53/
2. Navigate to your `cuffney.com` hosted zone
3. Create the following A records (for external/VPN access - internal network will use Unbound overrides):
   
   **OPNsense record** (themed name):
   - **Name**: `shire.cuffney.com`
     - **Type**: A
     - **Value**: Your public IP address
     - **TTL**: 300
   
   **Proxmox record** (themed name):
   - **Name**: `numenor.cuffney.com`
     - **Type**: A
     - **Value**: Your public IP address
     - **TTL**: 300
4. **Note**: These Route 53 records are primarily for external/VPN access. Internal network will use Unbound overrides (Task 1.9-1.10) which point to private IPs.

### Dynamic IP Address Considerations

**First, determine if you have a static or dynamic IP:**
- Check with your ISP, or
- Monitor your IP over several days - if it changes, you have a dynamic IP
- Most residential ISPs provide dynamic IPs

**Static IP**: If you have a static public IP from your ISP, you're all set. The Route 53 records will always point to the correct IP. No further action needed.

**Dynamic IP**: If your public IP changes (most residential ISPs), you have options:

**Option A: Manual Updates** (Recommended for now - simple and works fine)
- When your IP changes, manually update the Route 53 A records with the new IP
- Check your current public IP: `curl ifconfig.me` or `curl ipinfo.io/ip`
- **Note**: Most residential IPs don't change frequently (often only on router reboot or ISP maintenance)
- You can set up automation later if needed - manual updates work perfectly fine for most use cases

**Option B: Automatic Updates** (For future setup - optional)
- **Note**: OPNsense Dynamic DNS plugins may not be available in all versions
- **For now**: Use manual updates (Option A) - it's simple and works fine
- **Future automation options** (if you want to set up later):
  - **Script-based**: Create a script that runs on a schedule (cron job) to:
    1. Check current public IP: `curl ifconfig.me`
    2. Compare with Route 53 record
    3. Update Route 53 via AWS CLI/API if different
  - **Third-party DDNS**: Use a service like DuckDNS or No-IP, then point Route 53 to that service
  - **AWS Lambda**: Set up a Lambda function to periodically check and update Route 53

**Finding Your Public IP**:
```bash
# Check your current public IPv4 address (for Route 53 A records)
curl -4 ifconfig.me
# Returns: 38.49.92.238 (example - use your actual IP)

# Check IPv6 address (optional, for AAAA records)
curl -6 ifconfig.me
```

**Test**:

**Important**: When testing from your local network, Unbound DNS overrides will return private IPs (192.168.1.1). This is **correct behavior** - local devices should use private IPs. To test Route 53 records, you need to query an external DNS server.

**From your local network** (test Route 53 by querying external DNS):
```bash
# Query Google DNS to see Route 53 records
dig @8.8.8.8 shire.cuffney.com
# Should return your public IP (e.g., 38.49.92.238)

dig @8.8.8.8 numenor.cuffney.com
# Should return your public IP

# Using nslookup with external DNS
nslookup shire.cuffney.com 8.8.8.8
# Should return your public IP
```

**From external network** (mobile data, different network):
```bash
nslookup shire.cuffney.com
# Should resolve to your public IP (e.g., 38.49.92.238)

nslookup numenor.cuffney.com
# Should resolve to your public IP
```

**Expected behavior**:
- **Local network queries** (using OPNsense DNS): Return private IPs (192.168.1.1, 192.168.1.10) ✅
- **External queries** (using Route 53): Return public IP (38.49.92.238) ✅
- Both are correct - local devices use private IPs, external/VPN uses public IP

### Troubleshooting Route 53 Queries

If you get `SERVFAIL` or `REFUSED` errors when querying Route 53:

1. **Verify records exist in Route 53**:
   - Go to AWS Console → Route 53 → Hosted zones → `cuffney.com`
   - Confirm A records exist for `shire.cuffney.com`, `numenor.cuffney.com`, etc.
   - Check that records point to your public IP (not private IP)

2. **Check DNS propagation** (can take 5-60 minutes):
   ```bash
   # Query Route 53 name servers directly
   dig @ns-XXX.awsdns-XX.com shire.cuffney.com
   # Replace XXX with your actual Route 53 name servers (found in hosted zone)
   
   # Or wait a few minutes and try again
   dig @8.8.8.8 shire.cuffney.com
   ```

3. **Verify hosted zone is public**:
   - In Route 53 console, check that hosted zone type is "Public hosted zone"
   - Private hosted zones won't work for external access

4. **Check record configuration**:
   - Ensure record name is exactly `shire.cuffney.com` (not `shire` or `shire.cuffney.com.`)
   - Ensure record type is `A` (not `CNAME`)
   - Ensure value is your public IPv4 address (e.g., `38.49.92.238`)

5. **Test directly against Route 53 name servers**:
   ```bash
   # Find your Route 53 name servers in AWS Console
   # Then query them directly:
   dig @ns-XXX.awsdns-XX.com shire.cuffney.com
   ```

**Expected Result**: Route 53 records exist for themed hostnames (shire.cuffney.com, numenor.cuffney.com), and resolve to your public IP when queried from external DNS servers.
